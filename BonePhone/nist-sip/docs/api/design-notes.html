<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="M. Ranganathan">
   <meta name="GENERATOR" content="Mozilla/4.75 [en] (X11; U; Linux 2.2.14-5.0 i686) [Netscape]">
</head>
<body text="#000000" bgcolor="#FFFFFF" link="#0000FF" vlink="#FF0000" alink="#000088">

<center>
<h1>
Implementation&nbsp; Notes</h1></center>

<blockquote>The following implementation notes are intended to outline
the software architecture of the Parser.&nbsp; At present, they are very
sketchy but I intend to expand on them as needed.
<br>&nbsp;
<h2>
Header Classes</h2>
Each&nbsp; SIP header has its own header class. All individual&nbsp; SIP&nbsp;
Headers derive from the SIPHeader class.&nbsp; Whenever it is possible
to have multiple SIP Headers in a message,&nbsp; the derivation is from
the SIPHeaderList class. All SDPHeaders derive from the SDPHeader class.&nbsp;
Introspection is&nbsp; used to attach headers to SIPMessages. The class
hierarchy and structure closely mimics the grammar structure itself.
<br>&nbsp;
<h2>
Exceptions</h2>

<p><br>Exceptions generated during the parse result in calling a ParseExceptionHandler
callback if one is registered. The exception contains the exception message&nbsp;
(which is usually generated by antlr) and the header that generated the
exception.&nbsp; All exceptions derive from the base SIPException class.&nbsp;
The exception listener is called&nbsp; in each case if one is installed.
The exception listener can look at the exception class to proceed with
the processing of the message or abort the parse. The default action (when
a listener is not installed)&nbsp; is to ignore parse errors on individual
headers and throw exceptions when an illegal message is detected.
<h2>
Parsing SIP Headers</h2>
The parser&nbsp; uses the antlr LL(k) parser generator.&nbsp; The main
complication in using standard parser generator techniques is the lack
of&nbsp; keywords that are reserved for different types of headers or
even for different parts of a given header. Thus, for example, the SIP URL sip:sip:password@foo.bar.com
is valid, with the second sip: denoting a user name. The trick to getting
around this complication is to use multiple lexical analyzers, each with
a different set of reserved keywords, and switch between lexers in a context
dependent fashion. Several parser generators offer the ability to have
multiple token sets but insist that the token sets be disjoint. antlr allows
the token sets to intersect. This simplifies construction of the parser.&nbsp;
For example, considering the lexical analyzer&nbsp; 
(<a href="../../gov/nist/sip/msgparser/command_keywordLexer.g">command_keywordLexer.g</a>)
that recognizes header keywords,&nbsp; the keywords that are recognized
in this context are stored in a Hashtable. The lexical analyzer looks for
IDs which then resolve to the various keywords that identify headers.&nbsp;
The overall list of keywords, is in the class&nbsp; <a href="../../gov/nist/sip/msgparser/SIPKeywords.java">SIPKeywords</a>
and these are subsetted by the various lexical analyzers. The subsets are
not necessarily disjoint.&nbsp; All the lexers inherit rules from the basic
<a href="../../gov/nist/sip/msgparser/charLexer.g">charLexer</a>
which defines to common alphabet.&nbsp; The lexical analyzers are all called
*Lexer.g.&nbsp; Switching of lexical analyzers is done either in the lexical
analyzer itself or in the parser.&nbsp; In most cases,&nbsp; a lexical
analyzer can be switched in the lexer without any lookahead. However, in
some cases, lookahead is needed in order to determine which lexical analyzer
to choose next.&nbsp;
This is done in the common routine 
<i><font color="#000099">selectLexer</font></i>
which is defined in 
<a href="../../gov/nist/sip/msgparser/charLexer.g">charLexer</a>and
is inherited by all other lexers. 
<p>There are 4 parsers that are composed together to form the SIP/SDP parser.
In&nbsp; order to maximally exploit the commonality of the parsers,&nbsp;
I use the parser inheritance features that are provided by antlr.&nbsp;
The parsers and their functions are as follows:
<p>1. <a href="../../gov/nist/sip/msgparser/parser_utilParser.g">parser_utilParser
</a>is
a common set of utility functions that are inherited by other parsers.
<br>2. <a href="../../gov/nist/sip/msgparser/host_nameParser.g">host_nameParser</a>
is a parser that is used for parsing host names
<br>3. <a href="../../gov/nist/sip/msgparser/sip_urlParser.g">sip_urlParser</a>
is used for parsing sip URLs
<br>4. <a href="../../gov/nist/sip/msgparser/sdp_announceParser.g">sdp_announceParser
</a>which
is used for parsing sdp announcements.
<br>5.&nbsp; <a href="../../gov/nist/sip/msgparser/sip_messageParser.g">sip_messageParser</a>
which is used for parsing SIP messages and SIP headers.
<p>I use inheritance to reuse code, but unfortunately, antlr does not support
multiple inheritance and implements inheritance by copying, which has led
to a proliferation of code and and a lot of redundancy, making the class
files for the parser and lexical analyzers bloated. 
<p>In order to avoid complications while switching lexical analyzers from
the parser,&nbsp; in general, I have used the strategy of using syntactic
look ahead only with tokens that are common to the lexical analyzer being
switched to and the current lexical analyzer.&nbsp; Second, I only use
a&nbsp; single lookahead&nbsp; k = 1 in the parser. Whenever, a greater
k is needed, I use semantic look ahead instead.&nbsp; Switching lexers
from the parser has the advantage of reducing the number of rules that
are required and makes the resultant grammar smaller, however,&nbsp; it
is tricky to get right because of lookahead and&nbsp; syntactic look ahead
on non terminals.&nbsp; Switching lexers in a lexical analyzer is the preferred
approach and is used whenever possible.
<p>Please&nbsp; <a href="mailto:mranga@nist.gov">email me</a> with your
questions and comments so I can expand on this initial set of notes.
<br>&nbsp;</blockquote>

</body>
</html>
