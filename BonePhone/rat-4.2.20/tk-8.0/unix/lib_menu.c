/* This file is automatically generated by tcl2c, do NOT edit by hand! */
char lib_menu[] = "\
bind Menubutton <FocusIn> {}\n\
bind Menubutton <Enter> {\n\
tkMbEnter %W\n\
}\n\
bind Menubutton <Leave> {\n\
tkMbLeave %W\n\
}\n\
bind Menubutton <1> {\n\
if {$tkPriv(inMenubutton) != \"\"} {\n\
tkMbPost $tkPriv(inMenubutton) %X %Y\n\
}\n\
}\n\
bind Menubutton <Motion> {\n\
tkMbMotion %W up %X %Y\n\
}\n\
bind Menubutton <B1-Motion> {\n\
tkMbMotion %W down %X %Y\n\
}\n\
bind Menubutton <ButtonRelease-1> {\n\
tkMbButtonUp %W\n\
}\n\
bind Menubutton <space> {\n\
tkMbPost %W\n\
tkMenuFirstEntry [%W cget -menu]\n\
}\n\
bind Menu <FocusIn> {}\n\
bind Menu <Enter> {\n\
set tkPriv(window) %W\n\
if {[%W cget -type] == \"tearoff\"} {\n\
if {\"%m\" != \"NotifyUngrab\"} {\n\
if {$tcl_platform(platform) == \"unix\"} {\n\
tk_menuSetFocus %W\n\
}\n\
}\n\
}\n\
tkMenuMotion %W %x %y %s\n\
}\n\
bind Menu <Leave> {\n\
tkMenuLeave %W %X %Y %s\n\
}\n\
bind Menu <Motion> {\n\
tkMenuMotion %W %x %y %s\n\
}\n\
bind Menu <ButtonPress> {\n\
tkMenuButtonDown %W\n\
}\n\
bind Menu <ButtonRelease> {\n\
tkMenuInvoke %W 1\n\
}\n\
bind Menu <space> {\n\
tkMenuInvoke %W 0\n\
}\n\
bind Menu <Return> {\n\
tkMenuInvoke %W 0\n\
}\n\
bind Menu <Escape> {\n\
tkMenuEscape %W\n\
}\n\
bind Menu <Left> {\n\
tkMenuLeftArrow %W\n\
}\n\
bind Menu <Right> {\n\
tkMenuRightArrow %W\n\
}\n\
bind Menu <Up> {\n\
tkMenuUpArrow %W\n\
}\n\
bind Menu <Down> {\n\
tkMenuDownArrow %W\n\
}\n\
bind Menu <KeyPress> {\n\
tkTraverseWithinMenu %W %A\n\
}\n\
if {$tcl_platform(platform) == \"unix\"} {\n\
bind all <Alt-KeyPress> {\n\
tkTraverseToMenu %W %A\n\
}\n\
bind all <F10> {\n\
tkFirstMenu %W\n\
}\n\
} else {\n\
bind Menubutton <Alt-KeyPress> {\n\
tkTraverseToMenu %W %A\n\
}\n\
bind Menubutton <F10> {\n\
tkFirstMenu %W\n\
}\n\
}\n\
proc tkMbEnter w {\n\
global tkPriv\n\
if {$tkPriv(inMenubutton) != \"\"} {\n\
tkMbLeave $tkPriv(inMenubutton)\n\
}\n\
set tkPriv(inMenubutton) $w\n\
if {[$w cget -state] != \"disabled\"} {\n\
$w configure -state active\n\
}\n\
}\n\
proc tkMbLeave w {\n\
global tkPriv\n\
set tkPriv(inMenubutton) {}\n\
if {![winfo exists $w]} {\n\
return\n\
}\n\
if {[$w cget -state] == \"active\"} {\n\
$w configure -state normal\n\
}\n\
}\n\
proc tkMbPost {w {x {}} {y {}}} {\n\
global tkPriv errorInfo\n\
global tcl_platform\n\
if {([$w cget -state] == \"disabled\") || ($w == $tkPriv(postedMb))} {\n\
return\n\
}\n\
set menu [$w cget -menu]\n\
if {$menu == \"\"} {\n\
return\n\
}\n\
set tearoff [expr {($tcl_platform(platform) == \"unix\") \\\n\
|| ([$menu cget -type] == \"tearoff\")}]\n\
if {[string first $w $menu] != 0} {\n\
error \"can't post $menu:  it isn't a descendant of $w (this is a new requirement in Tk versions 3.0 and later)\"\n\
}\n\
set cur $tkPriv(postedMb)\n\
if {$cur != \"\"} {\n\
tkMenuUnpost {}\n\
}\n\
set tkPriv(cursor) [$w cget -cursor]\n\
set tkPriv(relief) [$w cget -relief]\n\
$w configure -cursor arrow\n\
$w configure -relief raised\n\
set tkPriv(postedMb) $w\n\
set tkPriv(focus) [focus]\n\
$menu activate none\n\
tkGenerateMenuSelect $menu\n\
update idletasks\n\
if {[catch {\n\
switch [$w cget -direction] {\n\
above {\n\
set x [winfo rootx $w]\n\
set y [expr {[winfo rooty $w] - [winfo reqheight $menu]}]\n\
$menu post $x $y\n\
}\n\
below {\n\
set x [winfo rootx $w]\n\
set y [expr {[winfo rooty $w] + [winfo height $w]}]\n\
$menu post $x $y\n\
}\n\
left {\n\
set x [expr {[winfo rootx $w] - [winfo reqwidth $menu]}]\n\
set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]\n\
set entry [tkMenuFindName $menu [$w cget -text]]\n\
if {[$w cget -indicatoron]} {\n\
if {$entry == [$menu index last]} {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [winfo reqheight $menu])/2}]\n\
} else {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [$menu yposition [expr {$entry+1}]])/2}]\n\
}\n\
}\n\
$menu post $x $y\n\
if {($entry != {}) && ([$menu entrycget $entry -state] != \"disabled\")} {\n\
$menu activate $entry\n\
tkGenerateMenuSelect $menu\n\
}\n\
}\n\
right {\n\
set x [expr {[winfo rootx $w] + [winfo width $w]}]\n\
set y [expr {(2 * [winfo rooty $w] + [winfo height $w]) / 2}]\n\
set entry [tkMenuFindName $menu [$w cget -text]]\n\
if {[$w cget -indicatoron]} {\n\
if {$entry == [$menu index last]} {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [winfo reqheight $menu])/2}]\n\
} else {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [$menu yposition [expr {$entry+1}]])/2}]\n\
}\n\
}\n\
$menu post $x $y\n\
if {($entry != {}) && ([$menu entrycget $entry -state] != \"disabled\")} {\n\
$menu activate $entry\n\
tkGenerateMenuSelect $menu\n\
}\n\
}\n\
default {\n\
if {[$w cget -indicatoron]} {\n\
if {$y == \"\"} {\n\
set x [expr {[winfo rootx $w] + [winfo width $w]/2}]\n\
set y [expr {[winfo rooty $w] + [winfo height $w]/2}]\n\
}\n\
tkPostOverPoint $menu $x $y [tkMenuFindName $menu [$w cget -text]]\n\
} else {\n\
$menu post [winfo rootx $w] [expr {[winfo rooty $w]+[winfo height $w]}]\n\
}  \n\
}\n\
}\n\
} msg]} {\n\
set savedInfo $errorInfo\n\
tkMenuUnpost {}\n\
error $msg $savedInfo\n\
}\n\
set tkPriv(tearoff) $tearoff\n\
if {$tearoff != 0} {\n\
focus $menu\n\
tkSaveGrabInfo $w\n\
grab -global $w\n\
}\n\
}\n\
proc tkMenuUnpost menu {\n\
global tcl_platform\n\
global tkPriv\n\
set mb $tkPriv(postedMb)\n\
catch {focus $tkPriv(focus)}\n\
set tkPriv(focus) \"\"\n\
catch {\n\
if {$mb != \"\"} {\n\
set menu [$mb cget -menu]\n\
$menu unpost\n\
set tkPriv(postedMb) {}\n\
$mb configure -cursor $tkPriv(cursor)\n\
$mb configure -relief $tkPriv(relief)\n\
} elseif {$tkPriv(popup) != \"\"} {\n\
$tkPriv(popup) unpost\n\
set tkPriv(popup) {}\n\
} elseif {(!([$menu cget -type] == \"menubar\")\n\
&& !([$menu cget -type] == \"tearoff\"))} {\n\
while 1 {\n\
set parent [winfo parent $menu]\n\
if {([winfo class $parent] != \"Menu\")\n\
|| ![winfo ismapped $parent]} {\n\
break\n\
}\n\
$parent activate none\n\
$parent postcascade none\n\
tkGenerateMenuSelect $parent\n\
set type [$parent cget -type]\n\
if {($type == \"menubar\")|| ($type == \"tearoff\")} {\n\
break\n\
}\n\
set menu $parent\n\
}\n\
if {[$menu cget -type] != \"menubar\"} {\n\
$menu unpost\n\
}\n\
}\n\
}\n\
if {($tkPriv(tearoff) != 0) || ($tkPriv(menuBar) != \"\")} {\n\
if {$menu != \"\"} {\n\
set grab [grab current $menu]\n\
if {$grab != \"\"} {\n\
grab release $grab\n\
}\n\
}\n\
tkRestoreOldGrab\n\
if {$tkPriv(menuBar) != \"\"} {\n\
$tkPriv(menuBar) configure -cursor $tkPriv(cursor)\n\
set tkPriv(menuBar) {}\n\
}\n\
if {$tcl_platform(platform) != \"unix\"} {\n\
set tkPriv(tearoff) 0\n\
}\n\
}\n\
}\n\
proc tkMbMotion {w upDown rootx rooty} {\n\
global tkPriv\n\
if {$tkPriv(inMenubutton) == $w} {\n\
return\n\
}\n\
set new [winfo containing $rootx $rooty]\n\
if {($new != $tkPriv(inMenubutton)) && (($new == \"\")\n\
|| ([winfo toplevel $new] == [winfo toplevel $w]))} {\n\
if {$tkPriv(inMenubutton) != \"\"} {\n\
tkMbLeave $tkPriv(inMenubutton)\n\
}\n\
if {($new != \"\") && ([winfo class $new] == \"Menubutton\")\n\
&& ([$new cget -indicatoron] == 0)\n\
&& ([$w cget -indicatoron] == 0)} {\n\
if {$upDown == \"down\"} {\n\
tkMbPost $new $rootx $rooty\n\
} else {\n\
tkMbEnter $new\n\
}\n\
}\n\
}\n\
}\n\
proc tkMbButtonUp w {\n\
global tkPriv\n\
global tcl_platform\n\
set tearoff [expr {($tcl_platform(platform) == \"unix\") \\\n\
|| ([[$w cget -menu] cget -type] == \"tearoff\")}]\n\
if {($tearoff != 0) && ($tkPriv(postedMb) == $w) \n\
&& ($tkPriv(inMenubutton) == $w)} {\n\
tkMenuFirstEntry [$tkPriv(postedMb) cget -menu]\n\
} else {\n\
tkMenuUnpost {}\n\
}\n\
}\n\
proc tkMenuMotion {menu x y state} {\n\
global tkPriv\n\
if {$menu == $tkPriv(window)} {\n\
if {[$menu cget -type] == \"menubar\"} {\n\
if {[info exists tkPriv(focus)] && \\\n\
([string compare $menu $tkPriv(focus)] != 0)} {\n\
$menu activate @$x,$y\n\
tkGenerateMenuSelect $menu\n\
}\n\
} else {\n\
$menu activate @$x,$y\n\
tkGenerateMenuSelect $menu\n\
}\n\
}\n\
if {($state & 0x1f00) != 0} {\n\
$menu postcascade active\n\
}\n\
}\n\
proc tkMenuButtonDown menu {\n\
global tkPriv\n\
global tcl_platform\n\
$menu postcascade active\n\
if {$tkPriv(postedMb) != \"\"} {\n\
grab -global $tkPriv(postedMb)\n\
} else {\n\
while {([$menu cget -type] == \"normal\") \n\
&& ([winfo class [winfo parent $menu]] == \"Menu\")\n\
&& [winfo ismapped [winfo parent $menu]]} {\n\
set menu [winfo parent $menu]\n\
}\n\
if {$tkPriv(menuBar) == {}} {\n\
set tkPriv(menuBar) $menu\n\
set tkPriv(cursor) [$menu cget -cursor]\n\
$menu configure -cursor arrow\n\
}\n\
if {$menu != [grab current $menu]} {\n\
tkSaveGrabInfo $menu\n\
}\n\
if {$tcl_platform(platform) == \"unix\"} {\n\
grab -global $menu\n\
}\n\
}\n\
}\n\
proc tkMenuLeave {menu rootx rooty state} {\n\
global tkPriv\n\
set tkPriv(window) {}\n\
if {[$menu index active] == \"none\"} {\n\
return\n\
}\n\
if {([$menu type active] == \"cascade\")\n\
&& ([winfo containing $rootx $rooty]\n\
== [$menu entrycget active -menu])} {\n\
return\n\
}\n\
$menu activate none\n\
tkGenerateMenuSelect $menu\n\
}\n\
proc tkMenuInvoke {w buttonRelease} {\n\
global tkPriv\n\
if {$buttonRelease && ($tkPriv(window) == \"\")} {\n\
$w postcascade none\n\
$w activate none\n\
event generate $w <<MenuSelect>>\n\
tkMenuUnpost $w\n\
return\n\
}\n\
if {[$w type active] == \"cascade\"} {\n\
$w postcascade active\n\
set menu [$w entrycget active -menu]\n\
tkMenuFirstEntry $menu\n\
} elseif {[$w type active] == \"tearoff\"} {\n\
tkMenuUnpost $w\n\
tkTearOffMenu $w\n\
} elseif {[$w cget -type] == \"menubar\"} {\n\
$w postcascade none\n\
$w activate none\n\
event generate $w <<MenuSelect>>\n\
tkMenuUnpost $w\n\
} else {\n\
tkMenuUnpost $w\n\
uplevel #0 [list $w invoke active]\n\
}\n\
}\n\
proc tkMenuEscape menu {\n\
set parent [winfo parent $menu]\n\
if {([winfo class $parent] != \"Menu\")} {\n\
tkMenuUnpost $menu\n\
} elseif {([$parent cget -type] == \"menubar\")} {\n\
tkMenuUnpost $menu\n\
tkRestoreOldGrab\n\
} else {\n\
tkMenuNextMenu $menu left\n\
}\n\
}\n\
proc tkMenuUpArrow {menu} {\n\
if {[$menu cget -type] == \"menubar\"} {\n\
tkMenuNextMenu $menu left\n\
} else {\n\
tkMenuNextEntry $menu -1\n\
}\n\
}\n\
proc tkMenuDownArrow {menu} {\n\
if {[$menu cget -type] == \"menubar\"} {\n\
tkMenuNextMenu $menu right\n\
} else {\n\
tkMenuNextEntry $menu 1\n\
}\n\
}\n\
proc tkMenuLeftArrow {menu} {\n\
if {[$menu cget -type] == \"menubar\"} {\n\
tkMenuNextEntry $menu -1\n\
} else {\n\
tkMenuNextMenu $menu left\n\
}\n\
}\n\
proc tkMenuRightArrow {menu} {\n\
if {[$menu cget -type] == \"menubar\"} {\n\
tkMenuNextEntry $menu 1\n\
} else {\n\
tkMenuNextMenu $menu right\n\
}\n\
}\n\
proc tkMenuNextMenu {menu direction} {\n\
global tkPriv\n\
if {$direction == \"right\"} {\n\
set count 1\n\
set parent [winfo parent $menu]\n\
set class [winfo class $parent]\n\
if {[$menu type active] == \"cascade\"} {\n\
$menu postcascade active\n\
set m2 [$menu entrycget active -menu]\n\
if {$m2 != \"\"} {\n\
tkMenuFirstEntry $m2\n\
}\n\
return\n\
} else {\n\
set parent [winfo parent $menu]\n\
while {($parent != \".\")} {\n\
if {([winfo class $parent] == \"Menu\")\n\
&& ([$parent cget -type] == \"menubar\")} {\n\
tk_menuSetFocus $parent\n\
tkMenuNextEntry $parent 1\n\
return\n\
}\n\
set parent [winfo parent $parent]\n\
}\n\
}\n\
} else {\n\
set count -1\n\
set m2 [winfo parent $menu]\n\
if {[winfo class $m2] == \"Menu\"} {\n\
if {[$m2 cget -type] != \"menubar\"} {\n\
$menu activate none\n\
tkGenerateMenuSelect $menu\n\
tk_menuSetFocus $m2\n\
set tmp [$m2 index active]\n\
$m2 activate none\n\
$m2 activate $tmp\n\
return\n\
}\n\
}\n\
}\n\
set m2 [winfo parent $menu]\n\
if {[winfo class $m2] == \"Menu\"} {\n\
if {[$m2 cget -type] == \"menubar\"} {\n\
tk_menuSetFocus $m2\n\
tkMenuNextEntry $m2 -1\n\
return\n\
}\n\
}\n\
set w $tkPriv(postedMb)\n\
if {$w == \"\"} {\n\
return\n\
}\n\
set buttons [winfo children [winfo parent $w]]\n\
set length [llength $buttons]\n\
set i [expr {[lsearch -exact $buttons $w] + $count}]\n\
while 1 {\n\
while {$i < 0} {\n\
incr i $length\n\
}\n\
while {$i >= $length} {\n\
incr i -$length\n\
}\n\
set mb [lindex $buttons $i]\n\
if {([winfo class $mb] == \"Menubutton\")\n\
&& ([$mb cget -state] != \"disabled\")\n\
&& ([$mb cget -menu] != \"\")\n\
&& ([[$mb cget -menu] index last] != \"none\")} {\n\
break\n\
}\n\
if {$mb == $w} {\n\
return\n\
}\n\
incr i $count\n\
}\n\
tkMbPost $mb\n\
tkMenuFirstEntry [$mb cget -menu]\n\
}\n\
proc tkMenuNextEntry {menu count} {\n\
global tkPriv\n\
if {[$menu index last] == \"none\"} {\n\
return\n\
}\n\
set length [expr {[$menu index last]+1}]\n\
set quitAfter $length\n\
set active [$menu index active]\n\
if {$active == \"none\"} {\n\
set i 0\n\
} else {\n\
set i [expr {$active + $count}]\n\
}\n\
while 1 {\n\
if {$quitAfter <= 0} {\n\
return\n\
}\n\
while {$i < 0} {\n\
incr i $length\n\
}\n\
while {$i >= $length} {\n\
incr i -$length\n\
}\n\
if {[catch {$menu entrycget $i -state} state] == 0} {\n\
if {$state != \"disabled\"} {\n\
break\n\
}\n\
}\n\
if {$i == $active} {\n\
return\n\
}\n\
incr i $count\n\
incr quitAfter -1\n\
}\n\
$menu activate $i\n\
tkGenerateMenuSelect $menu\n\
if {[$menu type $i] == \"cascade\"} {\n\
set cascade [$menu entrycget $i -menu]\n\
if {[string compare $cascade \"\"] != 0} {\n\
$menu postcascade $i\n\
tkMenuFirstEntry $cascade\n\
}\n\
}\n\
}\n\
proc tkMenuFind {w char} {\n\
global tkPriv\n\
set char [string tolower $char]\n\
set windowlist [winfo child $w]\n\
foreach child $windowlist {\n\
switch [winfo class $child] {\n\
Menu {\n\
if {[$child cget -type] == \"menubar\"} {\n\
if {$char == \"\"} {\n\
return $child\n\
}\n\
set last [$child index last]\n\
for {set i [$child cget -tearoff]} {$i <= $last} {incr i} {\n\
if {[$child type $i] == \"separator\"} {\n\
continue\n\
}\n\
set char2 [string index [$child entrycget $i -label] \\\n\
[$child entrycget $i -underline]]\n\
if {([string compare $char [string tolower $char2]] \\\n\
== 0) || ($char == \"\")} {\n\
if {[$child entrycget $i -state] != \"disabled\"} {\n\
return $child\n\
}\n\
}\n\
}\n\
}\n\
}\n\
}\n\
}\n\
foreach child $windowlist {\n\
switch [winfo class $child] {\n\
Menubutton {\n\
set char2 [string index [$child cget -text] \\\n\
[$child cget -underline]]\n\
if {([string compare $char [string tolower $char2]] == 0)\n\
|| ($char == \"\")} {\n\
if {[$child cget -state] != \"disabled\"} {\n\
return $child\n\
}\n\
}\n\
}\n\
default {\n\
set match [tkMenuFind $child $char]\n\
if {$match != \"\"} {\n\
return $match\n\
}\n\
}\n\
}\n\
}\n\
return {}\n\
}\n\
proc tkTraverseToMenu {w char} {\n\
global tkPriv\n\
if {$char == \"\"} {\n\
return\n\
}\n\
while {[winfo class $w] == \"Menu\"} {\n\
if {([$w cget -type] != \"menubar\") && ($tkPriv(postedMb) == \"\")} {\n\
return\n\
}\n\
if {[$w cget -type] == \"menubar\"} {\n\
break\n\
}\n\
set w [winfo parent $w]\n\
}\n\
set w [tkMenuFind [winfo toplevel $w] $char]\n\
if {$w != \"\"} {\n\
if {[winfo class $w] == \"Menu\"} {\n\
tk_menuSetFocus $w\n\
set tkPriv(window) $w\n\
tkSaveGrabInfo $w\n\
grab -global $w\n\
tkTraverseWithinMenu $w $char\n\
} else {\n\
tkMbPost $w\n\
tkMenuFirstEntry [$w cget -menu]\n\
}\n\
}\n\
}\n\
proc tkFirstMenu w {\n\
set w [tkMenuFind [winfo toplevel $w] \"\"]\n\
if {$w != \"\"} {\n\
if {[winfo class $w] == \"Menu\"} {\n\
tk_menuSetFocus $w\n\
set tkPriv(window) $w\n\
tkSaveGrabInfo $w\n\
grab -global $w\n\
tkMenuFirstEntry $w\n\
} else {\n\
tkMbPost $w\n\
tkMenuFirstEntry [$w cget -menu]\n\
}\n\
}\n\
}\n\
proc tkTraverseWithinMenu {w char} {\n\
if {$char == \"\"} {\n\
return\n\
}\n\
set char [string tolower $char]\n\
set last [$w index last]\n\
if {$last == \"none\"} {\n\
return\n\
}\n\
for {set i 0} {$i <= $last} {incr i} {\n\
if {[catch {set char2 [string index \\\n\
[$w entrycget $i -label] \\\n\
[$w entrycget $i -underline]]}]} {\n\
continue\n\
}\n\
if {[string compare $char [string tolower $char2]] == 0} {\n\
if {[$w type $i] == \"cascade\"} {\n\
$w activate $i\n\
$w postcascade active\n\
event generate $w <<MenuSelect>>\n\
set m2 [$w entrycget $i -menu]\n\
if {$m2 != \"\"} {\n\
tkMenuFirstEntry $m2\n\
}\n\
} else {\n\
tkMenuUnpost $w\n\
uplevel #0 [list $w invoke $i]\n\
}\n\
return\n\
}\n\
}\n\
}\n\
proc tkMenuFirstEntry menu {\n\
if {$menu == \"\"} {\n\
return\n\
}\n\
tk_menuSetFocus $menu\n\
if {[$menu index active] != \"none\"} {\n\
return\n\
}\n\
set last [$menu index last]\n\
if {$last == \"none\"} {\n\
return\n\
}\n\
for {set i 0} {$i <= $last} {incr i} {\n\
if {([catch {set state [$menu entrycget $i -state]}] == 0)\n\
&& ($state != \"disabled\") && ([$menu type $i] != \"tearoff\")} {\n\
$menu activate $i\n\
tkGenerateMenuSelect $menu\n\
if {[$menu type $i] == \"cascade\"} {\n\
set cascade [$menu entrycget $i -menu]\n\
if {[string compare $cascade \"\"] != 0} {\n\
$menu postcascade $i\n\
tkMenuFirstEntry $cascade\n\
}\n\
}\n\
return\n\
}\n\
}\n\
}\n\
proc tkMenuFindName {menu s} {\n\
set i \"\"\n\
if {![regexp {^active$|^last$|^none$|^[0-9]|^@} $s]} {\n\
catch {set i [$menu index $s]}\n\
return $i\n\
}\n\
set last [$menu index last]\n\
if {$last == \"none\"} {\n\
return\n\
}\n\
for {set i 0} {$i <= $last} {incr i} {\n\
if {![catch {$menu entrycget $i -label} label]} {\n\
if {$label == $s} {\n\
return $i\n\
}\n\
}\n\
}\n\
return \"\"\n\
}\n\
proc tkPostOverPoint {menu x y {entry {}}}  {\n\
global tcl_platform\n\
if {$entry != {}} {\n\
if {$entry == [$menu index last]} {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [winfo reqheight $menu])/2}]\n\
} else {\n\
incr y [expr {-([$menu yposition $entry] \\\n\
+ [$menu yposition [expr {$entry+1}]])/2}]\n\
}\n\
incr x [expr {-[winfo reqwidth $menu]/2}]\n\
}\n\
$menu post $x $y\n\
if {($entry != {}) && ([$menu entrycget $entry -state] != \"disabled\")} {\n\
$menu activate $entry\n\
tkGenerateMenuSelect $menu\n\
}\n\
}\n\
proc tkSaveGrabInfo w {\n\
global tkPriv\n\
set tkPriv(oldGrab) [grab current $w]\n\
if {$tkPriv(oldGrab) != \"\"} {\n\
set tkPriv(grabStatus) [grab status $tkPriv(oldGrab)]\n\
}\n\
}\n\
proc tkRestoreOldGrab {} {\n\
global tkPriv\n\
if {$tkPriv(oldGrab) != \"\"} {\n\
catch {\n\
if {$tkPriv(grabStatus) == \"global\"} {\n\
grab set -global $tkPriv(oldGrab)\n\
} else {\n\
grab set $tkPriv(oldGrab)\n\
}\n\
}\n\
set tkPriv(oldGrab) \"\"\n\
}\n\
}\n\
proc tk_menuSetFocus {menu} {\n\
global tkPriv\n\
if {![info exists tkPriv(focus)] || [string length $tkPriv(focus)] == 0} {\n\
set tkPriv(focus) [focus]\n\
}\n\
focus $menu\n\
}\n\
proc tkGenerateMenuSelect {menu} {\n\
global tkPriv\n\
if {([string compare $tkPriv(activeMenu) $menu] == 0) \\\n\
&& ([string compare $tkPriv(activeItem) [$menu index active]] \\\n\
== 0)} {\n\
return\n\
}\n\
set tkPriv(activeMenu) $menu\n\
set tkPriv(activeItem) [$menu index active]\n\
event generate $menu <<MenuSelect>>\n\
}\n\
proc tk_popup {menu x y {entry {}}} {\n\
global tkPriv\n\
global tcl_platform\n\
if {($tkPriv(popup) != \"\") || ($tkPriv(postedMb) != \"\")} {\n\
tkMenuUnpost {}\n\
}\n\
tkPostOverPoint $menu $x $y $entry\n\
if {$tcl_platform(platform) == \"unix\"} {\n\
tkSaveGrabInfo $menu\n\
grab -global $menu\n\
set tkPriv(popup) $menu\n\
tk_menuSetFocus $menu\n\
}\n\
}\n\
";
