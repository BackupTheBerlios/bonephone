/* This file is automatically generated by tcl2c, do NOT edit by hand! */
char lib_safe[] = "\
package require opt 0.2;\n\
namespace eval ::safe {\n\
namespace export interpCreate interpInit interpConfigure interpDelete \\\n\
interpAddToAccessPath interpFindInAccessPath \\\n\
setLogCmd ;\n\
proc ::safe::interpCreate {} {}\n\
proc ::safe::interpInit {} {}\n\
proc ::safe::interpConfigure {} {}\n\
set temp [::tcl::OptKeyRegister {\n\
{-accessPath -list {} \"access path for the slave\"}\n\
{-noStatics \"prevent loading of statically linked pkgs\"}\n\
{-statics true \"loading of statically linked pkgs\"}\n\
{-nestedLoadOk \"allow nested loading\"}\n\
{-nested false \"nested loading\"}\n\
{-deleteHook -script {} \"delete hook\"}\n\
}]\n\
::tcl::OptKeyRegister {\n\
{?slave? -name {} \"name of the slave (optional)\"}\n\
} ::safe::interpCreate ;\n\
lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp);\n\
::tcl::OptKeyRegister {\n\
{slave -name {} \"name of the slave\"}\n\
} ::safe::interpIC;\n\
lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp);\n\
::tcl::OptKeyDelete $temp;\n\
proc InterpStatics {} {\n\
foreach v {Args statics noStatics} {\n\
upvar $v $v\n\
}\n\
set flag [::tcl::OptProcArgGiven -noStatics];\n\
if {$flag && ($noStatics == $statics) \n\
&& ([::tcl::OptProcArgGiven -statics])} {\n\
return -code error\\\n\
\"conflicting values given for -statics and -noStatics\";\n\
}\n\
if {$flag} {\n\
return [expr {!$noStatics}];\n\
} else {\n\
return $statics\n\
}\n\
}\n\
proc InterpNested {} {\n\
foreach v {Args nested nestedLoadOk} {\n\
upvar $v $v\n\
}\n\
set flag [::tcl::OptProcArgGiven -nestedLoadOk];\n\
if {$flag && ($nestedLoadOk != $nested) \n\
&& ([::tcl::OptProcArgGiven -nested])} {\n\
return -code error\\\n\
\"conflicting values given for -nested and -nestedLoadOk\";\n\
}\n\
if {$flag} {\n\
return $nestedLoadOk\n\
} else {\n\
return $nested\n\
}\n\
}\n\
proc interpCreate {args} {\n\
set Args [::tcl::OptKeyParse ::safe::interpCreate $args]\n\
InterpCreate $slave $accessPath \\\n\
[InterpStatics] [InterpNested] $deleteHook;\n\
}\n\
proc interpInit {args} {\n\
set Args [::tcl::OptKeyParse ::safe::interpIC $args]\n\
if {![::interp exists $slave]} {\n\
return -code error \\\n\
\"\\\"$slave\\\" is not an interpreter\";\n\
}\n\
InterpInit $slave $accessPath \\\n\
[InterpStatics] [InterpNested] $deleteHook;\n\
}\n\
proc CheckInterp {slave} {\n\
if {![IsInterp $slave]} {\n\
return -code error \\\n\
\"\\\"$slave\\\" is not an interpreter managed by ::safe::\" ;\n\
}\n\
}\n\
proc interpConfigure {args} {\n\
switch [llength $args] {\n\
1 {\n\
set Args [::tcl::OptKeyParse ::safe::interpIC $args];\n\
CheckInterp $slave;\n\
set res {}\n\
lappend res [list -accessPath [Set [PathListName $slave]]]\n\
lappend res [list -statics    [Set [StaticsOkName $slave]]]\n\
lappend res [list -nested     [Set [NestedOkName $slave]]]\n\
lappend res [list -deleteHook [Set [DeleteHookName $slave]]]\n\
join $res\n\
}\n\
2 {\n\
::tcl::Lassign $args slave arg;\n\
set desc [lindex [::tcl::OptKeyGetDesc ::safe::interpIC] 2]\n\
set hits [::tcl::OptHits desc $arg];\n\
if {$hits > 1} {\n\
return -code error [::tcl::OptAmbigous $desc $arg]\n\
} elseif {$hits == 0} {\n\
return -code error [::tcl::OptFlagUsage $desc $arg]\n\
}\n\
CheckInterp $slave;\n\
set item [::tcl::OptCurDesc $desc];\n\
set name [::tcl::OptName $item];\n\
switch -exact -- $name {\n\
-accessPath {\n\
return [list -accessPath [Set [PathListName $slave]]]\n\
}\n\
-statics {\n\
return [list -statics    [Set [StaticsOkName $slave]]]\n\
}\n\
-nested {\n\
return [list -nested     [Set [NestedOkName $slave]]]\n\
}\n\
-deleteHook {\n\
return [list -deleteHook [Set [DeleteHookName $slave]]]\n\
}\n\
-noStatics {\n\
return -code error\\\n\
\"ambigous query (get or set -noStatics ?)\\\n\
use -statics instead\";\n\
}\n\
-nestedLoadOk {\n\
return -code error\\\n\
\"ambigous query (get or set -nestedLoadOk ?)\\\n\
use -nested instead\";\n\
}\n\
default {\n\
return -code error \"unknown flag $name (bug)\";\n\
}\n\
}\n\
}\n\
default {\n\
set Args [::tcl::OptKeyParse ::safe::interpIC $args];\n\
CheckInterp $slave;\n\
if {![::tcl::OptProcArgGiven -accessPath]} {\n\
set doreset 1\n\
set accessPath [Set [PathListName $slave]]\n\
} else {\n\
set doreset 0\n\
}\n\
if {    (![::tcl::OptProcArgGiven -statics]) \n\
&& (![::tcl::OptProcArgGiven -noStatics]) } {\n\
set statics    [Set [StaticsOkName $slave]]\n\
} else {\n\
set statics    [InterpStatics]\n\
}\n\
if {    ([::tcl::OptProcArgGiven -nested]) \n\
|| ([::tcl::OptProcArgGiven -nestedLoadOk]) } {\n\
set nested     [InterpNested]\n\
} else {\n\
set nested     [Set [NestedOkName $slave]]\n\
}\n\
if {![::tcl::OptProcArgGiven -deleteHook]} {\n\
set deleteHook [Set [DeleteHookName $slave]]\n\
}\n\
InterpSetConfig $slave $accessPath \\\n\
$statics $nested $deleteHook;\n\
if {$doreset} {\n\
if {[catch {::interp eval $slave {auto_reset}} msg]} {\n\
Log $slave \"auto_reset failed: $msg\";\n\
} else {\n\
Log $slave \"successful auto_reset\" NOTICE;\n\
}\n\
}\n\
}\n\
}\n\
}\n\
proc ::safe::InterpCreate {\n\
slave \n\
access_path\n\
staticsok\n\
nestedok\n\
deletehook\n\
} {\n\
if {[string compare \"\" $slave]} {\n\
::interp create -safe $slave;\n\
} else {\n\
set slave [::interp create -safe];\n\
}\n\
Log $slave \"Created\" NOTICE;\n\
InterpInit $slave $access_path $staticsok $nestedok $deletehook;\n\
}\n\
proc ::safe::InterpSetConfig {slave access_path staticsok\\\n\
nestedok deletehook} {\n\
if {[string match \"\" $access_path]} {\n\
set access_path [uplevel #0 set auto_path];\n\
set where [lsearch -exact $access_path [info library]];\n\
if {$where == -1} {\n\
set access_path [concat [list [info library]] $access_path];\n\
Log $slave \"tcl_library was not in auto_path,\\\n\
added it to slave's access_path\" NOTICE;\n\
} elseif {$where != 0} {\n\
set access_path [concat [list [info library]]\\\n\
[lreplace $access_path $where $where]];\n\
Log $slave \"tcl_libray was not in first in auto_path,\\\n\
moved it to front of slave's access_path\" NOTICE;\n\
}\n\
set access_path [AddSubDirs $access_path];\n\
}\n\
Log $slave \"Setting accessPath=($access_path) staticsok=$staticsok\\\n\
nestedok=$nestedok deletehook=($deletehook)\" NOTICE;\n\
set nname [PathNumberName $slave];\n\
if {[Exists $nname]} {\n\
set n [Set $nname];\n\
for {set i 0} {$i<$n} {incr i} {\n\
Unset [PathToken $i $slave];\n\
}\n\
}\n\
set slave_auto_path {}\n\
set i 0;\n\
foreach dir $access_path {\n\
Set [PathToken $i $slave] $dir;\n\
lappend slave_auto_path \"\\$[PathToken $i]\";\n\
incr i;\n\
}\n\
Set $nname $i;\n\
Set [PathListName $slave] $access_path;\n\
Set [VirtualPathListName $slave] $slave_auto_path;\n\
Set [StaticsOkName $slave] $staticsok\n\
Set [NestedOkName $slave] $nestedok\n\
Set [DeleteHookName $slave] $deletehook\n\
SyncAccessPath $slave;\n\
}\n\
proc ::safe::interpFindInAccessPath {slave path} {\n\
set access_path [GetAccessPath $slave];\n\
set where [lsearch -exact $access_path $path];\n\
if {$where == -1} {\n\
return -code error \"$path not found in access path $access_path\";\n\
}\n\
return \"\\$[PathToken $where]\";\n\
}\n\
proc ::safe::interpAddToAccessPath {slave path} {\n\
if {![catch {interpFindInAccessPath $slave $path} res]} {\n\
return $res;\n\
}\n\
set nname [PathNumberName $slave];\n\
set n [Set $nname];\n\
Set [PathToken $n $slave] $path;\n\
set token \"\\$[PathToken $n]\";\n\
Lappend [VirtualPathListName $slave] $token;\n\
Lappend [PathListName $slave] $path;\n\
Set $nname [expr {$n+1}];\n\
SyncAccessPath $slave;\n\
return $token;\n\
}\n\
proc ::safe::InterpInit {\n\
slave \n\
access_path\n\
staticsok\n\
nestedok\n\
deletehook\n\
} {\n\
InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook;\n\
::interp alias $slave source {} [namespace current]::AliasSource $slave\n\
::interp alias $slave load {} [namespace current]::AliasLoad $slave\n\
AliasSubset $slave file file dir.* join root.* ext.* tail \\\n\
path.* split\n\
::interp alias $slave exit {} [namespace current]::interpDelete $slave\n\
if {[catch {::interp eval $slave\\\n\
{source [file join $tcl_library init.tcl]}}\\\n\
msg]} {\n\
Log $slave \"can't source init.tcl ($msg)\";\n\
error \"can't source init.tcl into slave $slave ($msg)\"\n\
}\n\
return $slave\n\
}\n\
proc AddSubDirs {pathList} {\n\
set res {}\n\
foreach dir $pathList {\n\
if {[file isdirectory $dir]} {\n\
if {[lsearch -exact $res $dir]<0} {\n\
lappend res $dir;\n\
}\n\
foreach sub [glob -nocomplain -- [file join $dir *]] {\n\
if {    ([file isdirectory $sub])\n\
&& ([lsearch -exact $res $sub]<0) } {\n\
lappend res $sub;\n\
}\n\
}\n\
}\n\
}\n\
return $res;\n\
}\n\
proc ::safe::interpDelete {slave} {\n\
Log $slave \"About to delete\" NOTICE;\n\
set hookname [DeleteHookName $slave];\n\
if {[Exists $hookname]} {\n\
set hook [Set $hookname];\n\
if {![::tcl::Lempty $hook]} {\n\
Unset $hookname;\n\
if {[catch {eval $hook [list $slave]} err]} {\n\
Log $slave \"Delete hook error ($err)\";\n\
}\n\
}\n\
}\n\
set statename [InterpStateName $slave];\n\
if {[Exists $statename]} {\n\
Unset $statename;\n\
}\n\
if {[::interp exists $slave]} {\n\
::interp delete $slave;\n\
Log $slave \"Deleted\" NOTICE;\n\
}\n\
return\n\
}\n\
proc ::safe::setLogCmd {args} {\n\
variable Log;\n\
if {[llength $args] == 0} {\n\
return $Log;\n\
} else {\n\
if {[llength $args] == 1} {\n\
set Log [lindex $args 0];\n\
} else {\n\
set Log $args\n\
}\n\
}\n\
}\n\
variable Log {}\n\
proc SyncAccessPath {slave} {\n\
set slave_auto_path [Set [VirtualPathListName $slave]];\n\
::interp eval $slave [list set auto_path $slave_auto_path];\n\
Log $slave \\\n\
\"auto_path in $slave has been set to $slave_auto_path\"\\\n\
NOTICE;\n\
::interp eval $slave [list set tcl_library [lindex $slave_auto_path 0]];\n\
}\n\
proc InterpStateName {slave} {\n\
return \"S$slave\";\n\
}\n\
proc IsInterp {slave} {\n\
expr {    ([Exists [InterpStateName $slave]]) \n\
&& ([::interp exists $slave])}\n\
}\n\
proc PathToken {n {slave \"\"}} {\n\
if {[string compare \"\" $slave]} {\n\
return \"[InterpStateName $slave](access_path,$n)\";\n\
} else {\n\
return \"p(:$n:)\";\n\
}\n\
}\n\
proc PathListName {slave} {\n\
return \"[InterpStateName $slave](access_path)\";\n\
}\n\
proc VirtualPathListName {slave} {\n\
return \"[InterpStateName $slave](access_path_slave)\";\n\
}\n\
proc PathNumberName {slave} {\n\
return \"[InterpStateName $slave](access_path,n)\";\n\
}\n\
proc StaticsOkName {slave} {\n\
return \"[InterpStateName $slave](staticsok)\";\n\
}\n\
proc NestedOkName {slave} {\n\
return \"[InterpStateName $slave](nestedok)\";\n\
}\n\
proc Toplevel {args} {\n\
namespace eval [namespace current] $args;\n\
}\n\
proc Set {args} {\n\
eval Toplevel set $args;\n\
}\n\
proc Lappend {args} {\n\
eval Toplevel lappend $args;\n\
}\n\
proc Unset {args} {\n\
eval Toplevel unset $args;\n\
}\n\
proc Exists {varname} {\n\
Toplevel info exists $varname;\n\
}\n\
proc GetAccessPath {slave} {\n\
Set [PathListName $slave]\n\
}\n\
proc StaticsOk {slave} {\n\
Set [StaticsOkName $slave]\n\
}\n\
proc NestedOk {slave} {\n\
Set [NestedOkName $slave]\n\
}\n\
proc DeleteHookName {slave} {\n\
return [InterpStateName $slave](cleanupHook)\n\
}\n\
proc TranslatePath {slave path} {\n\
if {[regexp {(::)|(\\.\\.)} $path]} {\n\
error \"invalid characters in path $path\";\n\
}\n\
set n [expr {[Set [PathNumberName $slave]]-1}];\n\
for {} {$n>=0} {incr n -1} {\n\
set [PathToken $n] [Set [PathToken $n $slave]];\n\
}\n\
subst -nobackslashes -nocommands $path;\n\
}\n\
proc Log {slave msg {type ERROR}} {\n\
variable Log;\n\
if {[info exists Log] && [llength $Log]} {\n\
eval $Log [list \"$type for slave $slave : $msg\"];\n\
}\n\
}\n\
proc CheckFileName {slave file} {\n\
set ftail [file tail $file];\n\
if {[string length $ftail]>14} {\n\
error \"$ftail: filename too long\";\n\
}\n\
if {[regexp {\\..*\\.} $ftail]} {\n\
error \"$ftail: more than one dot is forbidden\";\n\
}\n\
if {[string compare $ftail \"tclIndex\"] && \\\n\
[string compare [string tolower [file extension $ftail]]\\\n\
\".tcl\"]} {\n\
error \"$ftail: must be a *.tcl or tclIndex\";\n\
}\n\
if {![file exists $file]} {\n\
error \"no such file or directory\";\n\
}\n\
if {![file readable $file]} {\n\
error \"not readable\";\n\
}\n\
}\n\
proc AliasSource {slave args} {\n\
set argc [llength $args];\n\
if {$argc != 1} {\n\
set msg \"wrong # args: should be \\\"source fileName\\\"\"\n\
Log $slave \"$msg ($args)\";\n\
return -code error $msg;\n\
}\n\
set file [lindex $args 0]\n\
if {[catch {set file [TranslatePath $slave $file]} msg]} {\n\
Log $slave $msg;\n\
return -code error \"permission denied\"\n\
}\n\
if {[catch {FileInAccessPath $slave $file} msg]} {\n\
Log $slave $msg;\n\
return -code error \"permission denied\"\n\
}\n\
if {[catch {CheckFileName $slave $file} msg]} {\n\
Log $slave \"$file:$msg\";\n\
return -code error $msg;\n\
}\n\
if {[catch {::interp invokehidden $slave source $file} msg]} {\n\
Log $slave $msg;\n\
return -code error \"script error\";\n\
}\n\
return $msg\n\
}\n\
proc AliasLoad {slave file args} {\n\
set argc [llength $args];\n\
if {$argc > 2} {\n\
set msg \"load error: too many arguments\";\n\
Log $slave \"$msg ($argc) {$file $args}\";\n\
return -code error $msg;\n\
}\n\
set package [lindex $args 0];\n\
set target [lindex $args 1];\n\
if {[string length $target]} {\n\
if {![NestedOk $slave]} {\n\
Log $slave \"loading to a sub interp (nestedok)\\\n\
disabled (trying to load $package to $target)\";\n\
return -code error \"permission denied (nested load)\";\n\
}\n\
}\n\
if {[string length $file] == 0} {\n\
if {[string length $package] == 0} {\n\
set msg \"load error: empty filename and no package name\";\n\
Log $slave $msg;\n\
return -code error $msg;\n\
}\n\
if {![StaticsOk $slave]} {\n\
Log $slave \"static packages loading disabled\\\n\
(trying to load $package to $target)\";\n\
return -code error \"permission denied (static package)\";\n\
}\n\
} else {\n\
if {[catch {set file [TranslatePath $slave $file]} msg]} {\n\
Log $slave $msg;\n\
return -code error \"permission denied\"\n\
}\n\
if {[catch {FileInAccessPath $slave $file} msg]} {\n\
Log $slave $msg;\n\
return -code error \"permission denied (path)\"\n\
}\n\
}\n\
if {[catch {::interp invokehidden\\\n\
$slave load $file $package $target} msg]} {\n\
Log $slave $msg;\n\
return -code error $msg\n\
}\n\
return $msg\n\
}\n\
proc FileInAccessPath {slave file} {\n\
set access_path [GetAccessPath $slave];\n\
if {[file isdirectory $file]} {\n\
error \"\\\"$file\\\": is a directory\"\n\
}\n\
set parent [file dirname $file]\n\
if {[lsearch -exact $access_path $parent] == -1} {\n\
error \"\\\"$file\\\": not in access_path\";\n\
}\n\
}\n\
proc Subset {slave command okpat args} {\n\
set subcommand [lindex $args 0]\n\
if {[regexp $okpat $subcommand]} {\n\
return [eval {$command $subcommand} [lrange $args 1 end]]\n\
}\n\
set msg \"not allowed to invoke subcommand $subcommand of $command\";\n\
Log $slave $msg;\n\
error $msg;\n\
}\n\
proc AliasSubset {slave alias target args} {\n\
set pat ^(; set sep \"\"\n\
foreach sub $args {\n\
append pat $sep$sub\n\
set sep |\n\
}\n\
append pat )\\$\n\
::interp alias $slave $alias {}\\\n\
[namespace current]::Subset $slave $target $pat\n\
}\n\
}\n\
";
