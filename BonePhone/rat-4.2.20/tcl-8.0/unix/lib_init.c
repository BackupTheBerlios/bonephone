/* This file is automatically generated by tcl2c, do NOT edit by hand! */
char lib_init[] = "\
if {[info commands package] == \"\"} {\n\
error \"version mismatch: library\\nscripts expect Tcl version 7.5b1 or later but the loaded version is\\nonly [info patchlevel]\"\n\
}\n\
package require -exact Tcl 8.0\n\
if {![info exists auto_path]} {\n\
if {[catch {set auto_path $env(TCLLIBPATH)}]} {\n\
set auto_path \"\"\n\
}\n\
}\n\
if {(![interp issafe]) && ($tcl_platform(platform) == \"windows\")} {\n\
namespace eval tcl {\n\
proc envTraceProc {lo n1 n2 op} {\n\
set x $::env($n2)\n\
set ::env($lo) $x\n\
set ::env([string toupper $lo]) $x\n\
}\n\
}\n\
foreach p [array names env] {\n\
set u [string toupper $p]\n\
if {$u != $p} {\n\
switch -- $u {\n\
COMSPEC -\n\
PATH {\n\
if {![info exists env($u)]} {\n\
set env($u) $env($p)\n\
}\n\
trace variable env($p) w [list tcl::envTraceProc $p]\n\
trace variable env($u) w [list tcl::envTraceProc $p]\n\
}\n\
}\n\
}\n\
}\n\
if {[info exists p]} {\n\
unset p\n\
}\n\
if {[info exists u]} {\n\
unset u\n\
}\n\
if {![info exists env(COMSPEC)]} {\n\
if {$tcl_platform(os) == {Windows NT}} {\n\
set env(COMSPEC) cmd.exe\n\
} else {\n\
set env(COMSPEC) command.com\n\
}\n\
}\n\
}\n\
package unknown tclPkgUnknown\n\
if {[info commands exec] == \"\"} {\n\
set auto_noexec 1\n\
}\n\
set errorCode \"\"\n\
set errorInfo \"\"\n\
if {[info commands tclLog] == \"\"} {\n\
proc tclLog {string} {\n\
catch {puts stderr $string}\n\
}\n\
}\n\
proc unknown args {\n\
global auto_noexec auto_noload env unknown_pending tcl_interactive\n\
global errorCode errorInfo\n\
set cmd [lindex $args 0]\n\
if {[regexp \"^namespace\\[ \\t\\n\\]+inscope\" $cmd] && [llength $cmd] == 4} {\n\
set arglist [lrange $args 1 end]\n\
set ret [catch {uplevel $cmd $arglist} result]\n\
if {$ret == 0} {\n\
return $result\n\
} else {\n\
return -code $ret -errorcode $errorCode $result\n\
}\n\
}\n\
return -code error \"invalid command name \\\"$name\\\"\"\n\
}\n\
proc auto_load {cmd {namespace {}}} {\n\
return 0\n\
}\n\
proc auto_load_index {} {\n\
global auto_index auto_oldpath auto_path errorInfo errorCode\n\
if {[info exists auto_oldpath]} {\n\
if {$auto_oldpath == $auto_path} {\n\
return 0\n\
}\n\
}\n\
set auto_oldpath $auto_path\n\
set issafe [interp issafe]\n\
for {set i [expr {[llength $auto_path] - 1}]} {$i >= 0} {incr i -1} {\n\
set dir [lindex $auto_path $i]\n\
set f \"\"\n\
if {$issafe} {\n\
catch {source [file join $dir tclIndex]}\n\
} elseif {[catch {set f [open [file join $dir tclIndex]]}]} {\n\
continue\n\
} else {\n\
set error [catch {\n\
set id [gets $f]\n\
if {$id == \"# Tcl autoload index file, version 2.0\"} {\n\
eval [read $f]\n\
} elseif {$id == \\\n\
\"# Tcl autoload index file: each line identifies a Tcl\"} {\n\
while {[gets $f line] >= 0} {\n\
if {([string index $line 0] == \"#\")\n\
|| ([llength $line] != 2)} {\n\
continue\n\
}\n\
set name [lindex $line 0]\n\
set auto_index($name) \\\n\
\"source [file join $dir [lindex $line 1]]\"\n\
}\n\
} else {\n\
error \\\n\
\"[file join $dir tclIndex] isn't a proper Tcl index file\"\n\
}\n\
} msg]\n\
if {$f != \"\"} {\n\
close $f\n\
}\n\
if {$error} {\n\
error $msg $errorInfo $errorCode\n\
}\n\
}\n\
}\n\
return 1\n\
}\n\
proc auto_qualify {cmd namespace} {\n\
set n [regsub -all {::+} $cmd :: cmd]\n\
if {[regexp {^::(.*)$} $cmd x tail]} {\n\
if {$n > 1} {\n\
return [list $cmd]\n\
} else {\n\
return [list $tail]\n\
}\n\
}\n\
if {$n == 0} {\n\
if {[string compare $namespace ::] == 0} {\n\
return [list $cmd]\n\
} else {\n\
return [list ${namespace}::$cmd $cmd]\n\
}\n\
} else {\n\
if {[string compare $namespace ::] == 0} {\n\
return [list ::$cmd]\n\
} else {\n\
return [list ${namespace}::$cmd ::$cmd]\n\
}\n\
}\n\
}\n\
proc auto_import {pattern} {\n\
global auto_index\n\
set ns [uplevel namespace current]\n\
set patternList [auto_qualify $pattern $ns]\n\
auto_load_index\n\
foreach pattern $patternList {\n\
foreach name [array names auto_index] {\n\
if {[string match $pattern $name] && \"\" == [info commands $name]} {\n\
uplevel #0 $auto_index($name)\n\
}\n\
}\n\
}\n\
}\n\
if {[string compare $tcl_platform(platform) windows] == 0} {\n\
proc auto_execok name {\n\
global auto_execs env tcl_platform\n\
if {[info exists auto_execs($name)]} {\n\
return $auto_execs($name)\n\
}\n\
set auto_execs($name) \"\"\n\
if {[lsearch -exact {cls copy date del erase dir echo mkdir md rename \n\
ren rmdir rd time type ver vol} $name] != -1} {\n\
return [set auto_execs($name) [list $env(COMSPEC) /c $name]]\n\
}\n\
if {[llength [file split $name]] != 1} {\n\
foreach ext {{} .com .exe .bat} {\n\
set file ${name}${ext}\n\
if {[file exists $file] && ![file isdirectory $file]} {\n\
return [set auto_execs($name) [list $file]]\n\
}\n\
}\n\
return \"\"\n\
}\n\
set path \"[file dirname [info nameof]];.;\"\n\
if {[info exists env(WINDIR)]} {\n\
set windir $env(WINDIR) \n\
}\n\
if {[info exists windir]} {\n\
if {$tcl_platform(os) == \"Windows NT\"} {\n\
append path \"$windir/system32;\"\n\
}\n\
append path \"$windir/system;$windir;\"\n\
}\n\
if {[info exists env(PATH)]} {\n\
append path $env(PATH)\n\
}\n\
foreach dir [split $path {;}] {\n\
if {$dir == \"\"} {\n\
set dir .\n\
}\n\
foreach ext {{} .com .exe .bat} {\n\
set file [file join $dir ${name}${ext}]\n\
if {[file exists $file] && ![file isdirectory $file]} {\n\
return [set auto_execs($name) [list $file]]\n\
}\n\
}\n\
}\n\
return \"\"\n\
}\n\
} else {\n\
proc auto_execok name {\n\
global auto_execs env\n\
if {[info exists auto_execs($name)]} {\n\
return $auto_execs($name)\n\
}\n\
set auto_execs($name) \"\"\n\
if {[llength [file split $name]] != 1} {\n\
if {[file executable $name] && ![file isdirectory $name]} {\n\
set auto_execs($name) [list $name]\n\
}\n\
return $auto_execs($name)\n\
}\n\
foreach dir [split $env(PATH) :] {\n\
if {$dir == \"\"} {\n\
set dir .\n\
}\n\
set file [file join $dir $name]\n\
if {[file executable $file] && ![file isdirectory $file]} {\n\
set auto_execs($name) [list $file]\n\
return $auto_execs($name)\n\
}\n\
}\n\
return \"\"\n\
}\n\
}\n\
proc auto_reset {} {\n\
global auto_execs auto_index auto_oldpath\n\
foreach p [info procs] {\n\
if {[info exists auto_index($p)] && ![string match auto_* $p]\n\
&& ([lsearch -exact {unknown pkg_mkIndex tclPkgSetup tcl_findLibrary\n\
tclMacPkgSearch tclPkgUnknown} $p] < 0)} {\n\
rename $p {}\n\
}\n\
}\n\
catch {unset auto_execs}\n\
catch {unset auto_index}\n\
catch {unset auto_oldpath}\n\
}\n\
proc tcl_findLibrary {basename version patch initScript enVarName varName} {\n\
upvar #0 $varName the_library\n\
global env\n\
set dirs {}\n\
set errors {}\n\
if {[info exist the_library]} {\n\
lappend dirs $the_library\n\
} else {\n\
if {[info exists env($enVarName)]} {\n\
lappend dirs $env($enVarName)\n\
}\n\
lappend dirs [file join [file dirname [info library]] $basename$version]\n\
set parentDir [file dirname [file dirname [info nameofexecutable]]]\n\
set grandParentDir [file dirname $parentDir]\n\
lappend dirs [file join $parentDir lib $basename$version]\n\
lappend dirs [file join $grandParentDir lib $basename$version]\n\
lappend dirs [file join $parentDir library]\n\
lappend dirs [file join $grandParentDir library]\n\
if [string match {*[ab]*} $patch] {\n\
set ver $patch\n\
} else {\n\
set ver $version\n\
}\n\
lappend dirs [file join $grandParentDir] $basename$ver library]\n\
lappend dirs [file join [file dirname $grandParentDir] $basename$ver library]\n\
}\n\
foreach i $dirs {\n\
set the_library $i\n\
set file [file join $i $initScript]\n\
if {[interp issafe] || [file exists $file]} {\n\
if {![catch {uplevel #0 [list source $file]} msg]} {\n\
return\n\
} else {\n\
append errors \"$file: $msg\\n$errorInfo\\n\"\n\
}\n\
}\n\
}\n\
set msg \"Can't find a usable $initScript in the following directories: \\n\"\n\
append msg \"    $dirs\\n\\n\"\n\
append msg \"$errors\\n\\n\"\n\
append msg \"This probably means that $basename wasn't installed properly.\\n\"\n\
error $msg\n\
}\n\
if {[interp issafe]} {\n\
proc auto_mkindex {dir args} {\n\
error \"can't generate index within safe interpreter\"\n\
}\n\
proc tcl_nonsafe {args} {}\n\
} else {\n\
proc tcl_nonsafe {args} {eval $args}\n\
}\n\
tcl_nonsafe proc auto_mkindex {dir args} {\n\
global errorCode errorInfo\n\
if {[interp issafe]} {\n\
error \"can't generate index within safe interpreter\"\n\
}\n\
set oldDir [pwd]\n\
cd $dir\n\
set dir [pwd]\n\
append index \"# Tcl autoload index file, version 2.0\\n\"\n\
append index \"# This file is generated by the \\\"auto_mkindex\\\" command\\n\"\n\
append index \"# and sourced to set up indexing information for one or\\n\"\n\
append index \"# more commands.  Typically each line is a command that\\n\"\n\
append index \"# sets an element in the auto_index array, where the\\n\"\n\
append index \"# element name is the name of a command and the value is\\n\"\n\
append index \"# a script that loads the command.\\n\\n\"\n\
if {$args == \"\"} {\n\
set args *.tcl\n\
}\n\
auto_mkindex_parser::init\n\
foreach file [eval glob $args] {\n\
if {[catch {auto_mkindex_parser::mkindex $file} msg] == 0} {\n\
append index $msg\n\
} else {\n\
set code $errorCode\n\
set info $errorInfo\n\
cd $oldDir\n\
error $msg $info $code\n\
}\n\
}\n\
auto_mkindex_parser::cleanup\n\
set fid [open \"tclIndex\" w]\n\
puts $fid $index nonewline\n\
close $fid\n\
cd $oldDir\n\
}\n\
proc auto_mkindex_old {dir args} {\n\
global errorCode errorInfo\n\
set oldDir [pwd]\n\
cd $dir\n\
set dir [pwd]\n\
append index \"# Tcl autoload index file, version 2.0\\n\"\n\
append index \"# This file is generated by the \\\"auto_mkindex\\\" command\\n\"\n\
append index \"# and sourced to set up indexing information for one or\\n\"\n\
append index \"# more commands.  Typically each line is a command that\\n\"\n\
append index \"# sets an element in the auto_index array, where the\\n\"\n\
append index \"# element name is the name of a command and the value is\\n\"\n\
append index \"# a script that loads the command.\\n\\n\"\n\
if {$args == \"\"} {\n\
set args *.tcl\n\
}\n\
foreach file [eval glob $args] {\n\
set f \"\"\n\
set error [catch {\n\
set f [open $file]\n\
while {[gets $f line] >= 0} {\n\
if {[regexp {^proc[ 	]+([^ 	]*)} $line match procName]} {\n\
set procName [lindex [auto_qualify $procName \"::\"] 0]\n\
append index \"set [list auto_index($procName)]\"\n\
append index \" \\[list source \\[file join \\$dir [list $file]\\]\\]\\n\"\n\
}\n\
}\n\
close $f\n\
} msg]\n\
if {$error} {\n\
set code $errorCode\n\
set info $errorInfo\n\
catch {close $f}\n\
cd $oldDir\n\
error $msg $info $code\n\
}\n\
}\n\
set f \"\"\n\
set error [catch {\n\
set f [open tclIndex w]\n\
puts $f $index nonewline\n\
close $f\n\
cd $oldDir\n\
} msg]\n\
if {$error} {\n\
set code $errorCode\n\
set info $errorInfo\n\
catch {close $f}\n\
cd $oldDir\n\
error $msg $info $code\n\
}\n\
}\n\
namespace eval auto_mkindex_parser {\n\
variable parser \"\"          ;# parser used to build index\n\
variable index \"\"           ;# maintains index as it is built\n\
variable scriptFile \"\"      ;# name of file being processed\n\
variable contextStack \"\"    ;# stack of namespace scopes\n\
variable imports \"\"         ;# keeps track of all imported cmds\n\
variable initCommands \"\"    ;# list of commands that create aliases\n\
proc init {} {\n\
variable parser\n\
variable initCommands\n\
if {![interp issafe]} {\n\
set parser [interp create -safe]\n\
$parser hide info\n\
$parser hide rename\n\
$parser hide proc\n\
$parser hide namespace\n\
$parser hide eval\n\
$parser hide puts\n\
$parser invokehidden namespace delete ::\n\
$parser invokehidden proc unknown {args} {}\n\
$parser expose namespace\n\
$parser invokehidden rename namespace _%@namespace\n\
$parser expose eval\n\
$parser invokehidden rename eval _%@eval\n\
foreach cmd $initCommands {\n\
eval $cmd\n\
}\n\
}\n\
}\n\
proc cleanup {} {\n\
variable parser\n\
interp delete $parser\n\
unset parser\n\
}\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::mkindex {file} {\n\
variable parser\n\
variable index\n\
variable scriptFile\n\
variable contextStack\n\
variable imports\n\
set scriptFile $file\n\
set fid [open $file]\n\
set contents [read $fid]\n\
close $fid\n\
regsub -all {([^\\$])\\$([^\\$])} $contents {\\1\\\\$\\2} contents\n\
set index \"\"\n\
set contextStack \"\"\n\
set imports \"\"\n\
$parser eval $contents\n\
foreach name $imports {\n\
catch {$parser eval [list _%@namespace forget $name]}\n\
}\n\
return $index\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::hook {cmd} {\n\
variable initCommands\n\
lappend initCommands $cmd\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::slavehook {cmd} {\n\
variable initCommands\n\
lappend initCommands \"\\$parser eval [list $cmd]\"\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::command {name arglist body} {\n\
hook [list auto_mkindex_parser::commandInit $name $arglist $body]\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::commandInit {name arglist body} {\n\
variable parser\n\
set ns [namespace qualifiers $name]\n\
set tail [namespace tail $name]\n\
if {$ns == \"\"} {\n\
set fakeName \"[namespace current]::_%@fake_$tail\"\n\
} else {\n\
set fakeName \"_%@fake_$name\"\n\
regsub -all {::} $fakeName \"_\" fakeName\n\
set fakeName \"[namespace current]::$fakeName\"\n\
}\n\
proc $fakeName $arglist $body\n\
if {[regexp {::} $name]} {\n\
set exportCmd [list _%@namespace export [namespace tail $name]]\n\
$parser eval [list _%@namespace eval $ns $exportCmd]\n\
set alias [namespace tail $fakeName]\n\
$parser invokehidden proc $name {args} \"_%@eval $alias \\$args\"\n\
$parser alias $alias $fakeName\n\
} else {\n\
$parser alias $name $fakeName\n\
}\n\
return\n\
}\n\
tcl_nonsafe proc auto_mkindex_parser::fullname {name} {\n\
variable contextStack\n\
if {![string match ::* $name]} {\n\
foreach ns $contextStack {\n\
set name \"${ns}::$name\"\n\
if {[string match ::* $name]} {\n\
break\n\
}\n\
}\n\
}\n\
if {[namespace qualifiers $name] == \"\"} {\n\
return [namespace tail $name]\n\
} elseif {![string match ::* $name]} {\n\
return \"::$name\"\n\
}\n\
return $name\n\
}\n\
tcl_nonsafe auto_mkindex_parser::command proc {name args} {\n\
variable index\n\
variable scriptFile\n\
append index \"set [list auto_index([fullname $name])]\"\n\
append index \" \\[list source \\[file join \\$dir [list $scriptFile]\\]\\]\\n\"\n\
}\n\
tcl_nonsafe auto_mkindex_parser::command namespace {op args} {\n\
switch -- $op {\n\
eval {\n\
variable parser\n\
variable contextStack\n\
set name [lindex $args 0]\n\
set args [lrange $args 1 end]\n\
set contextStack [linsert $contextStack 0 $name]\n\
if {[llength $args] == 1} {\n\
$parser eval [lindex $args 0]\n\
} else {\n\
eval $parser eval $args\n\
}\n\
set contextStack [lrange $contextStack 1 end]\n\
}\n\
import {\n\
variable parser\n\
variable imports\n\
foreach pattern $args {\n\
if {$pattern != \"-force\"} {\n\
lappend imports $pattern\n\
}\n\
}\n\
catch {$parser eval \"_%@namespace import $args\"}\n\
}\n\
}\n\
}\n\
rename tcl_nonsafe \"\"\n\
proc pkg_mkIndex {args} {\n\
global errorCode errorInfo\n\
set usage {\"pkg_mkIndex ?-nopkgrequire? ?-direct? ?-verbose? dir ?pattern ...?\"};\n\
set argCount [llength $args]\n\
if {$argCount < 1} {\n\
return -code error \"wrong # args: should be\\n$usage\"\n\
}\n\
set more \"\"\n\
set direct 0\n\
set noPkgRequire 0\n\
set doVerbose 0\n\
for {set idx 0} {$idx < $argCount} {incr idx} {\n\
set flag [lindex $args $idx]\n\
switch -glob -- $flag {\n\
-- {\n\
incr idx\n\
break\n\
}\n\
-verbose {\n\
set doVerbose 1\n\
}\n\
-direct {\n\
set direct 1\n\
append more \" -direct\"\n\
}\n\
-nopkgrequire {\n\
set noPkgRequire 1\n\
append more \" -nopkgrequire\"\n\
}\n\
-* {\n\
return -code error \"unknown flag $flag: should be\\n$usage\"\n\
}\n\
default {\n\
break\n\
}\n\
}\n\
}\n\
set dir [lindex $args $idx]\n\
set patternList [lrange $args [expr $idx + 1] end]\n\
if {[llength $patternList] == 0} {\n\
set patternList [list \"*.tcl\" \"*[info sharedlibextension]\"]\n\
}\n\
append index \"# Tcl package index file, version 1.1\\n\"\n\
append index \"# This file is generated by the \\\"pkg_mkIndex$more\\\" command\\n\"\n\
append index \"# and sourced either when an application starts up or\\n\"\n\
append index \"# by a \\\"package unknown\\\" script.  It invokes the\\n\"\n\
append index \"# \\\"package ifneeded\\\" command to set up package-related\\n\"\n\
append index \"# information so that packages will be loaded automatically\\n\"\n\
append index \"# in response to \\\"package require\\\" commands.  When this\\n\"\n\
append index \"# script is sourced, the variable \\$dir must contain the\\n\"\n\
append index \"# full path name of this file's directory.\\n\"\n\
set oldDir [pwd]\n\
cd $dir\n\
foreach file [eval glob $patternList] {\n\
set toProcess($file) 1\n\
}\n\
while {[array size toProcess] > 0} {\n\
set processed 0\n\
foreach file [array names toProcess] {\n\
set c [interp create]\n\
foreach pkg [info loaded] {\n\
if {[lindex $pkg 1] == \"Tk\"} {\n\
$c eval {set argv {-geometry +0+0}}\n\
}\n\
load [lindex $pkg 0] [lindex $pkg 1] $c\n\
}\n\
foreach pkg [array names files] {\n\
$c eval \"package ifneeded $pkg\\\n\
\\[list tclPkgSetup $dir \\\n\
[lrange $pkg 0 0] [lrange $pkg 1 1]\\\n\
[list $files($pkg)]\\]\"\n\
}\n\
if {$noPkgRequire == 1} {\n\
$c eval {\n\
rename package __package_orig\n\
proc package {what args} {\n\
switch -- $what {\n\
require { return ; # ignore transitive requires }\n\
default { eval __package_orig {$what} $args }\n\
}\n\
}\n\
proc __dummy args {}\n\
package unknown __dummy\n\
}\n\
} else {\n\
$c eval {\n\
rename package __package_orig\n\
proc package {what args} {\n\
switch -- $what {\n\
require {\n\
eval __package_orig require $args\n\
set ::__ignorePkgs([lindex $args 0]) 1\n\
}\n\
provide {\n\
if {([info level] == 1) \\\n\
&& ([llength $args] == 2)} {\n\
lappend ::__providedPkgs [lindex $args 0]\n\
}\n\
eval __package_orig provide $args\n\
}\n\
default { eval __package_orig {$what} $args }\n\
}\n\
}\n\
}\n\
}\n\
$c eval [list set __file $file]\n\
$c eval [list set __direct $direct]\n\
if {[catch {\n\
$c eval {\n\
set __doingWhat \"loading or sourcing\"\n\
proc tclPkgSetup {dir pkg version files} {\n\
foreach __p [package names] {\n\
set __localIgnorePkgs($__p) 1\n\
}\n\
foreach __ns [__pkgGetAllNamespaces] {\n\
set __localIgnoreNs($__ns) 1\n\
if {[info exists ::__ignoreNs($__ns)] == 0} {\n\
namespace import ${__ns}::*\n\
}\n\
}\n\
foreach __cmd [info commands] {\n\
set __localIgnoreCmds($__cmd) 1\n\
}\n\
package provide $pkg $version\n\
foreach __fileInfo $files {\n\
set __f [lindex $__fileInfo 0]\n\
set __type [lindex $__fileInfo 1]\n\
if {$__type == \"load\"} {\n\
load [file join $dir $__f] $pkg\n\
} else {\n\
source [file join $dir $__f]\n\
}\n\
}\n\
foreach __p [package names] {\n\
if {[info exists __localIgnorePkgs($__p)] == 0} {\n\
set ::__ignorePkgs($__p) 1\n\
}\n\
}\n\
foreach __ns [__pkgGetAllNamespaces] {\n\
if {([info exists __localIgnoreNs($__ns)] == 0) \\\n\
&& ([info exists ::__ignoreNs($__ns)] == 0)} {\n\
namespace import ${__ns}::*\n\
set ::__ignoreNs($__ns) 1\n\
}\n\
}\n\
foreach __cmd [info commands] {\n\
if {[info exists __localIgnoreCmds($__cmd)] == 0} {\n\
lappend ::__ignoreCmds $__cmd\n\
}\n\
}\n\
}\n\
proc __pkgGetAllNamespaces {{root {}}} {\n\
set __list $root\n\
foreach __ns [namespace children $root] {\n\
eval lappend __list [__pkgGetAllNamespaces $__ns]\n\
}\n\
return $__list\n\
}\n\
set ::__ignorePkgs(Tcl) 1\n\
set ::__ignorePkgs(Tk) 1\n\
foreach __pkg [package names] {\n\
set ::__ignorePkgs($__pkg) 1\n\
}\n\
foreach __ns [__pkgGetAllNamespaces] {\n\
set ::__ignoreNs($__ns) 1\n\
namespace import ${__ns}::*\n\
}\n\
set ::__ignoreCmds [info commands]\n\
set dir \"\"		;# in case file is pkgIndex.tcl\n\
set __pkgs {}\n\
set __providedPkgs {}\n\
if {[string compare [file extension $__file] \\\n\
[info sharedlibextension]] == 0} {\n\
set __doingWhat loading\n\
load [file join . $__file]\n\
set __type load\n\
} else {\n\
set __doingWhat sourcing\n\
source $__file\n\
set __type source\n\
}\n\
foreach __ns [__pkgGetAllNamespaces] {\n\
if {[info exists ::__ignoreNs($__ns)] == 0} {\n\
namespace import ${__ns}::*\n\
}\n\
}\n\
foreach __i [info commands] {\n\
set __cmds($__i) 1\n\
}\n\
foreach __i $::__ignoreCmds {\n\
catch {unset __cmds($__i)}\n\
}\n\
foreach __i [array names __cmds] {\n\
set __absolute [namespace origin $__i]\n\
set __absolute [auto_qualify $__absolute ::]\n\
if {[string compare $__i $__absolute] != 0} {\n\
set __cmds($__absolute) 1\n\
unset __cmds($__i)\n\
}\n\
}\n\
foreach __i $::__providedPkgs {\n\
lappend __pkgs [list $__i [package provide $__i]]\n\
set __ignorePkgs($__i) 1\n\
}\n\
foreach __i [package names] {\n\
if {([string compare [package provide $__i] \"\"] != 0) \\\n\
&& ([info exists ::__ignorePkgs($__i)] == 0)} {\n\
lappend __pkgs [list $__i [package provide $__i]]\n\
}\n\
}\n\
}\n\
} msg] == 1} {\n\
set what [$c eval set __doingWhat]\n\
if {$doVerbose} {\n\
tclLog \"warning: error while $what $file: $msg\\nthis file will be retried in the next pass\"\n\
}\n\
} else {\n\
set type [$c eval set __type]\n\
set cmds [lsort [$c eval array names __cmds]]\n\
set pkgs [$c eval set __pkgs]\n\
if {[llength $pkgs] > 1} {\n\
tclLog \"warning: \\\"$file\\\" provides more than one package ($pkgs)\"\n\
}\n\
foreach pkg $pkgs {\n\
lappend files($pkg) [list $file $type $cmds]\n\
}\n\
incr processed\n\
unset toProcess($file)\n\
if {$doVerbose} {\n\
tclLog \"processed $file\"\n\
}\n\
}\n\
interp delete $c\n\
}\n\
if {$processed == 0} {\n\
tclLog \"this iteration could not process any files: giving up here\"\n\
break\n\
}\n\
}\n\
foreach pkg [lsort [array names files]] {\n\
append index \"\\npackage ifneeded $pkg \"\n\
if {$direct} {\n\
set cmdList {}\n\
foreach elem $files($pkg) {\n\
set file [lindex $elem 0]\n\
set type [lindex $elem 1]\n\
lappend cmdList \"\\[list $type \\[file join \\$dir\\\n\
[list $file]\\]\\]\"\n\
}\n\
append index [join $cmdList \"\\\\n\"]\n\
} else {\n\
append index \"\\[list tclPkgSetup \\$dir [lrange $pkg 0 0]\\\n\
[lrange $pkg 1 1] [list $files($pkg)]\\]\"\n\
}\n\
}\n\
set f [open pkgIndex.tcl w]\n\
puts $f $index\n\
close $f\n\
cd $oldDir\n\
}\n\
proc tclPkgSetup {dir pkg version files} {\n\
global auto_index\n\
package provide $pkg $version\n\
foreach fileInfo $files {\n\
set f [lindex $fileInfo 0]\n\
set type [lindex $fileInfo 1]\n\
foreach cmd [lindex $fileInfo 2] {\n\
if {$type == \"load\"} {\n\
set auto_index($cmd) [list load [file join $dir $f] $pkg]\n\
} else {\n\
set auto_index($cmd) [list source [file join $dir $f]]\n\
} \n\
}\n\
}\n\
}\n\
proc tclMacPkgSearch {dir} {\n\
foreach x [glob -nocomplain [file join $dir *.shlb]] {\n\
if {[file isfile $x]} {\n\
set res [resource open $x]\n\
foreach y [resource list TEXT $res] {\n\
if {$y == \"pkgIndex\"} {source -rsrc pkgIndex}\n\
}\n\
catch {resource close $res}\n\
}\n\
}\n\
}\n\
proc tclPkgUnknown {name version {exact {}}} {\n\
return\n\
global auto_path tcl_platform env\n\
if {![info exists auto_path]} {\n\
return\n\
}\n\
for {set i [expr {[llength $auto_path] - 1}]} {$i >= 0} {incr i -1} {\n\
catch {\n\
foreach file [glob -nocomplain [file join [lindex $auto_path $i] \\\n\
* pkgIndex.tcl]] {\n\
set dir [file dirname $file]\n\
if {[catch {source $file} msg]} {\n\
tclLog \"error reading package index file $file: $msg\"\n\
}\n\
}\n\
}\n\
set dir [lindex $auto_path $i]\n\
set file [file join $dir pkgIndex.tcl]\n\
if {[interp issafe] || [file readable $file]} {\n\
if {[catch {source $file} msg] && ![interp issafe]}  {\n\
tclLog \"error reading package index file $file: $msg\"\n\
}\n\
}\n\
if {(![interp issafe]) && ($tcl_platform(platform) == \"macintosh\")} {\n\
set dir [lindex $auto_path $i]\n\
tclMacPkgSearch $dir\n\
foreach x [glob -nocomplain [file join $dir *]] {\n\
if {[file isdirectory $x]} {\n\
set dir $x\n\
tclMacPkgSearch $dir\n\
}\n\
}\n\
}\n\
}\n\
}\n\
";
